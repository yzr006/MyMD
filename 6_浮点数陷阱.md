# 现象
```javascript
0.1 + 0.2 === 0.3 // false
9999999999999999 === 10000000000000000 // true
```
# 结论
- 浮点数计算不精确，不是任何语言的bug，而是标准所致。
- 大致原因：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中，要先转换为2进制进行计算，这个过程中出现了精度丢失，即误差。
- 解决方法：对于需要精确结果的场景，别直接使用浮点数进行计算。现阶段可以使用big.js解决，等以后JS实现了Decimal，就可以使用Decimal类型计算了。

# 标准
首先，在计算机中，任何数字的存储、计算，底层都是以二进制的形式进行的。

JS中的数字，是按照“IEEE 754 双精度 64 位浮点数”标准，来存储的。这个标准规定的二进制数字存储格式为：
```js
S * M * 2^E
```
其中：
- S，是符号位，占用1位，表示正负
- M，是底数，有52位。由于左起第一位永远是1，所以还存在一位hidden bit，即隐藏位，所以实际上可以存储53位。
- E，指数位。有11位。

# 复习一下数字进制转换
由于电脑进行十进制数字运算时，会先把十进制，转换成二进制，所以我们先看一下具体的转换方法：

## 十进制整数，转二进制
规则：除以2，商继续除以2，得到0为止，将余数逆序排列

例如：

```js
// 十进制：13，转二进制
13 / 2 // 6,余1
6 / 2  // 3,余0
3 / 2  // 1,余1
1 / 2  // 0,余1
// 余数倒序排列，结果为：1101 
```

## 十进制小数，转二进制
规则：乘以2，取整，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列

例如：
```js
// 十进制：0.8125，转二进制
0.8125 * 2 // 1.625, 取整：1
0.625 * 2  // 1.25,  取整：1
0.25 * 2   // 0.5,   取整：0
0.5 * 2    // 1.0,   取整：1
// 取整部分正序排列，结果为：0.1101
```
# 无法精确表达
回到一开始的问题：
```js
0.1 + 0.2 === 0.3 // false
```
先把0.1转成二进制：0.0 0011 0011 0011 … （循环 0011）

再把0.2转成二进制：0.0011 0011 0011 … （循环 0011）

计算过程大致如下：

```js
  1.100110011001100... * 2^-4
+ 1.100110011001100... * 2^-3

-->

  0.1100110011001100... * 2^-3
+ 1.100110011001100...  * 2^-3

-->

= 10.011001100...001 * 2^-3

-->

= 0.010011001100...001 // 二进制
= 0.30000000000000004  // 十进制
```

从这个计算过程，可以看出，只有当十进制的小数，转成二进制，按标准表示法，底数不超过52位的时候，这个小数，才能在电脑里精确表达。

否则多出的位数，都会被舍弃，造成精度丢失，计算结果自然也就不准确了。

## 那么，文章开始时的第二个问题，又是怎么回事呢？

我们印象中，JS可以表达的最大的数字，应该是

`Number.MAX_VALUE : 1.7976931348623157 * 10^308`

然而`Number`对象还提供了另外一个静态属性：

`Number.MAX_SAFE_INTEGER : 9007199254740991`

为啥呢？先看一段代码：

```js
var x = 1;
while(x != x + 1) x++;
// x = 9007199254740992 即 2^53
```
这段代码，看起来说明了一个问题，当一个整数大于`9007199254740992` 的时候，其精度就开始出现问题，导致`x == x+1`

这里大家可能有2个疑问：
- 为啥精度会出问题？
- 既然是从`9007199254740992`才开始出问题的，那么应该比这个数字大的数，才是不“安全”的，为啥`Number.MAX_SAFE_INTEGER `不是`9007199254740992`，而是`9007199254740991`呢？难道所谓的“最大安全整数”有问题？

分析一下：

```js
// 9007199254740992，即2^53用二进制表示
10000...000  // 53个0
// 9007199254740993，即 2^53 + 1，用二进制表示
10000...001  // 52个0
// 把 2^53 + 1 按照标准来存储，即为：
10000...000 * 2^1  // 52个0。显然，最后一位，已经丢失了
```
精度丢失的原因找到了，而且可以看出，其实从`9007199254740992`这个数字开始，转换成标准格式后，已经丢失了最后一位0了，所以“最大安全整数”，`Number.MAX_SAFE_INTEGER = 9007199254740991`是没有问题的。

文章开始的第二个问题，跟这里的情况，几乎是一样的。

# 总结
小数和超长整数的精度丢失，对于使用 IEEE 754 浮点数标准来存储浮点类型的任何编程语言（除了JS，还有C, C++, JAVA），都是存在的。

在 C#、Java 中，提供了 Decimal、BigDecimal原生支持来解决精度问题。

只是JS暂未提供较好的原生解决方案，不过在ES规范中，Decimal已经被提出来了，但暂未正式采纳。

以上。

